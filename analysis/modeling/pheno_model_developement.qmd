---
title: "Model_development"
format: html
editor: visual
---

```{r}

library(tidyverse)
library(phenofit)
library(sf)
library(patchwork)
library(lme4)
library(lmerTest)
library(MuMIn)
library(performance)
library(caret)
library(mgcv)

```

```{r}

read_rds("../data/processed_trees_ndvi_lc_climate.rds") -> tree_ldc_metrics_climate 

```

```{r}

tree_ldc_metrics_climate %>%
  group_by(species_common, leaf_persistence) %>%
  summarize(n = length(unique(UID))) %>% 
  filter(n > 50) %>% 
  pull(1) -> species_list

pheno_vars <- c("DER.pos_doy", "Greenup_doy", "Maturity_doy", 
                "Senescence_doy", "Dormancy_doy", "growing_season")

```

# Corrilation Matrixs by species and dependent variables

```{r}

pheno_vars <- c("DER.sos_doy", "DER.eos_doy", "DER.pos_doy")  

sos_climate <- c("late_winter_prcp_days", "late_winter_temp", "late_winter_prcp", 
                 "winter_temp", "winter_prcp", "winter_prcp_days", 
                 "early_spring_temp", "early_spring_prcp_days", "early_spring_prcp",
                 "spring_prcp_days", "spring_temp", "spring_prcp", "impervious_90m", "irrigated_90m")

eos_climate <- c("summer_temp", "summer_prcp", "summer_prcp_days","late_summer_prcp", 
                 "late_summer_prcp_days", "late_summer_temp", "fall_temp", 
                 "fall_prcp", "fall_prcp_days", "early_fall_prcp", 
                 "early_fall_prcp_days", "early_fall_temp",
                 "late_fall_prcp", "late_fall_prcp_days", "late_fall_temp", "impervious_90m", "irrigated_90m")

pos_climate <- c("late_spring_temp", "late_spring_prcp", "late_spring_prcp_days", "impervious_90m", "irrigated_90m") 

all_climate_vars <- unique(c(sos_climate, eos_climate, pos_climate))

calc_species_cor <- function(species_name, data){
  data %>% 
    filter(year < 2025, species_common == species_name) %>% 
    select(all_of(c(pheno_vars, all_climate_vars))) %>% 
    cor(use = "pairwise.complete.obs") %>% 
    as.data.frame() %>% 
    rownames_to_column("pheno_var") %>% 
    filter(pheno_var %in% pheno_vars) %>% 
    select(pheno_var, all_of(all_climate_vars)) %>% 
    pivot_longer(-pheno_var, names_to = "climate_var", values_to = "correlation") %>% 
    filter(
      (pheno_var == "DER.sos_doy" & climate_var %in% sos_climate) |
      (pheno_var == "DER.eos_doy" & climate_var %in% eos_climate) |
      (pheno_var == "DER.pos_doy" & climate_var %in% pos_climate) |
      (pheno_var == "DER.pos_doy" & climate_var %in% pos_climate) |
      (pheno_var == "DER.pos_doy" & climate_var %in% pos_climate) |
      (pheno_var == "DER.pos_doy" & climate_var %in% pos_climate) |
      (pheno_var == "DER.pos_doy" & climate_var %in% pos_climate) 
    ) %>% 
    rename(!!species_name := correlation)
}

# Calculate for all species
map(species_list, ~calc_species_cor(.x, tree_ldc_metrics_climate)) %>% 
  compact() %>%  # Remove NULL values
  reduce(full_join, by = c("pheno_var", "climate_var")) -> all_cors 

all_cors %>% 
  pivot_longer(cols = -c(pheno_var, climate_var), 
               names_to = "species", 
               values_to = "correlation") %>% 
  mutate(group = "Individual Species") %>% 
  bind_rows(
    all_cors %>% 
      pivot_longer(cols = -c(pheno_var, climate_var), 
                   names_to = "species", 
                   values_to = "correlation") %>% 
      group_by(pheno_var, climate_var) %>% 
      summarise(correlation = mean(correlation, na.rm = TRUE), .groups = "drop") %>% 
      mutate(species = "Average", group = "Average")
  ) %>% 
  
  ggplot(aes(x = species, y = climate_var, fill = correlation)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = sprintf("%.2f", correlation)), size = 2) +
  scale_fill_gradient2(low = "red", mid = "white", high = "darkgreen",
                       midpoint = 0, limits = c(-1, 1), 
                       name = "Correlation") +
  facet_grid(pheno_var ~ group, scales = "free", space = "free") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    axis.text.y = element_text(size = 7),
    axis.title = element_blank(),
    strip.text = element_text(face = "bold")
  ) +
  labs(title = "Phenology-Climate Correlations Across Species")

```

```{r}

# Updated phenology variables to match your labels
pheno_vars <- c("DER.pos_doy", "Greenup_doy", "Maturity_doy", 
                "Senescence_doy", "Dormancy_doy", "growing_season")

# Use only existing climate variables
greenup_climate <- c("late_winter_temp", "late_winter_prcp")

maturity_climate <- c("late_spring_mean_tmax", "spring_prcp")

senescence_climate <- c("late_summer_prcp", "early_fall_mean_tmax")

dormancy_climate <- c("fall_cumulative_prcp", "fall_mean_tmax")

pos_climate <- c("late_spring_cumulative_prcp", "spring_temp")

growing_climate <- c("irrigated_90m", "late_summer_prcp", "summer_temp")

all_climate_vars <- unique(c(greenup_climate, maturity_climate, senescence_climate, 
                             dormancy_climate, pos_climate, growing_climate))

calc_species_cor <- function(species_name, data){
  data %>% 
    filter(year < 2025, species_common == species_name) %>% 
    select(all_of(c(pheno_vars, all_climate_vars))) %>% 
    cor(use = "pairwise.complete.obs") %>% 
    as.data.frame() %>% 
    rownames_to_column("pheno_var") %>% 
    filter(pheno_var %in% pheno_vars) %>% 
    select(pheno_var, all_of(all_climate_vars)) %>% 
    pivot_longer(-pheno_var, names_to = "climate_var", values_to = "correlation") %>% 
    filter(
      (pheno_var == "Greenup_doy" & climate_var %in% greenup_climate) |
      (pheno_var == "Maturity_doy" & climate_var %in% maturity_climate) |
      (pheno_var == "DER.pos_doy" & climate_var %in% pos_climate)|
      (pheno_var == "Senescence_doy" & climate_var %in% senescence_climate) |
      (pheno_var == "Dormancy_doy" & climate_var %in% dormancy_climate) |
      (pheno_var == "growing_season" & climate_var %in% growing_climate)
    ) %>% 
    rename(!!species_name := correlation)
}

# Calculate for all species
map(species_list, ~calc_species_cor(.x, tree_ldc_metrics_climate)) %>% 
  compact() %>%
  reduce(full_join, by = c("pheno_var", "climate_var")) -> all_cors

# Labels
pheno_labels <- c(
  "DER.pos_doy" = "POS",
  "Greenup_doy" = "Green-up",
  "Maturity_doy" = "Maturity",
  "Senescence_doy" = "Senescence",
  "Dormancy_doy" = "Dormancy",
  "growing_season" = "Growing Season"  
)

# Plot
all_cors %>% 
  pivot_longer(cols = -c(pheno_var, climate_var), 
               names_to = "species", 
               values_to = "correlation") %>% 
  mutate(group = "Individual Species") %>% 
  bind_rows(
    all_cors %>% 
      pivot_longer(cols = -c(pheno_var, climate_var), 
                   names_to = "species", 
                   values_to = "correlation") %>% 
      group_by(pheno_var, climate_var) %>% 
      summarise(correlation = mean(correlation, na.rm = TRUE), .groups = "drop") %>% 
      mutate(species = "Average", group = "Average")
  ) %>% 
  mutate(pheno_var = pheno_labels[pheno_var]) %>%
  ggplot(aes(x = species, y = climate_var, fill = correlation)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = sprintf("%.2f", correlation)), size = 2) +
  scale_fill_gradient2(low = "red", mid = "white", high = "darkgreen",
                       midpoint = 0, limits = c(-1, 1), 
                       name = "Correlation") +
  facet_grid(pheno_var ~ group, scales = "free", space = "free") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    axis.text.y = element_text(size = 7),
    axis.title = element_blank(),
    strip.text = element_text(face = "bold")
  ) +
  labs(title = "Phenology-Climate Correlations Across Species")

```

```{r}

source("../R/plot_year.R")

plot_year(tree_ldc_metrics_climate, "2020", "10006", metrics = c("Inflection","DER.pos")) 
plot_year(tree_ldc_metrics_climate, "2020", "10006", metrics = c("Derivative")) 


# Create a data frame from the input object
df <- data.frame(
  t = tree_ldc_metrics_climate$season_data[[1]]$t,
  y = tree_ldc_metrics_climate$season_data[[1]]$y
)

# Plot with smoother
ggplot(df, aes(x = t, y = y)) +
  geom_point(alpha = 0.5)+
  theme_minimal()

```

# Variable Selection for the Mixed Effect Panel Model

```{r, warning=FALSE}

data_complete <- tree_ldc_metrics_climate %>% 
  dplyr::select(Greenup_date:Dormancy_date, DER.pos_doy, UID, winter_prcp:water_250m, growing_season) %>% 
  mutate(Greenup_date = as.numeric(Greenup_date),
         Maturity_date = as.numeric(Maturity_date),
         DER.pos_doy = as.numeric(DER.pos_doy),
         Senescence_date = as.numeric(Senescence_date),
         Dormancy_date = as.numeric(Dormancy_date)) %>%  
  filter(complete.cases(.))

global_greening_model <- lmer(
  Greenup_date ~ winter_prcp + winter_prcp_days + winter_temp + 
    winter_mean_tmax + late_winter_prcp + late_winter_prcp_days + 
    late_winter_temp + late_winter_mean_tmax + spring_prcp + 
    spring_prcp_days + spring_temp + spring_mean_tmax + 
    early_spring_prcp + early_spring_prcp_days + early_spring_temp + 
    early_spring_mean_tmax + impervious_90m + irrigated_90m + 
    later_winter_cumulative_prcp + spring_prcp_cumulative_prcp + 
    early_spring_cumulative_prcp + (1 | UID),
  data = data_complete,
  REML = FALSE,
  na.action = "na.fail"
)

global_maturity_model <- lmer(
  Maturity_date ~ spring_prcp + spring_temp + spring_mean_tmax +
    late_spring_prcp + late_spring_temp + late_spring_mean_tmax +
    summer_prcp + summer_temp + summer_mean_tmax +
    spring_prcp_cumulative_prcp + late_spring_cumulative_prcp +
    impervious_90m + irrigated_90m + water_250m +
    (1 | UID),
  data = data_complete,
  REML = FALSE,
  na.action = "na.fail"
)

global_pos_model <- lmer(
  DER.pos_doy ~ spring_prcp + spring_temp + spring_mean_tmax +
    late_spring_prcp + late_spring_temp + late_spring_mean_tmax +
    summer_prcp + summer_temp + summer_mean_tmax +
    spring_prcp_cumulative_prcp + late_spring_cumulative_prcp +
    impervious_90m + irrigated_90m + water_250m +
    (1 | UID),
  data = data_complete,
  REML = FALSE,
  na.action = "na.fail"
)

global_senescence_model <- lmer(
  Senescence_date ~ late_summer_prcp + 
    #late_summer_temp + 
    late_summer_mean_tmax +
    summer_cumulative_prcp + 
    late_summer_cumulative_prcp +
    fall_prcp + 
    #fall_temp + 
    #fall_mean_tmax +
    early_fall_prcp + 
    early_fall_temp + 
    early_fall_mean_tmax +
    impervious_90m + irrigated_90m + water_250m +
    (1 | UID),
  data = data_complete,
  REML = FALSE,
  na.action = "na.fail"
)

global_dormancy_model <- lmer(
  Dormancy_date ~ fall_prcp + fall_temp + fall_mean_tmax +
    late_fall_prcp + late_fall_temp + late_fall_mean_tmax +
    fall_cumulative_prcp + late_fall_cumulative_prcp +
    winter_prcp + winter_temp + winter_mean_tmax +
    impervious_90m + irrigated_90m + water_250m +
    (1 | UID),
  data = data_complete,
  REML = FALSE,
  na.action = "na.fail"
)

global_gs_model <- lmer(
  growing_season ~ spring_prcp + spring_temp + 
                   summer_prcp + summer_temp +
                   late_summer_prcp + late_summer_temp +
                   fall_prcp + fall_temp +
                   spring_prcp_cumulative_prcp +
                   late_spring_cumulative_prcp +
                   summer_cumulative_prcp +
                   late_summer_cumulative_prcp +
                   fall_cumulative_prcp +
                   impervious_90m + irrigated_90m + water_250m +
                   (1 | UID),
  data = data_complete,
  REML = FALSE,
  na.action = "na.fail"
)

```

## Stepwise to find the best combination of 4 variables

```{r, warning=FALSE}

# all_models_greening <- dredge(global_greening_model, m.max = 2)
# all_maturity_models <- dredge(global_maturity_model, m.max = 4)
# all_pos_models <- dredge(global_pos_model, m.max = 4)
# all_senescence_models <- dredge(global_senescence_model, m.max = 4)
# all_dormancy_models <- dredge(global_dormancy_model, m.max = 4)
#all_gs_models <- dredge(global_gs_model, m.max = 4)

```

## Overview of the top 10 Best Models

```{r}

#head(all_models_greening, 10)

```

## Finding the best model

```{r}

# best_greening <- get.models(all_models_greening, subset = 1)[[1]]
# best_maturity <- get.models(all_maturity_models, subset = 1)[[1]]
# best_pos <- get.models(all_pos_models, subset = 1)[[1]]
# best_senescence <- get.models(all_senescence_models, subset = 1)[[1]]
# best_dormancy <- get.models(all_dormancy_models, subset = 1)[[1]]
#best_season <- get.models(all_gs_models, subset = 1)[[1]]
# 
# summary(best_greening)
# summary(best_maturity)
# summary(best_pos)
# summary(best_senescence)
# summary(best_dormancy)
#summary(best_season)

```

# Mixed Effect Model top level regressions for each species, unique intercpes for each tree. Using k-fold cross validation to check model preforamance.

```{r}

climate_vars <- list(
  Greenup_doy = c("late_winter_temp_z", "late_winter_prcp_z"),
  Maturity_doy = c("late_spring_mean_tmax_z", "spring_prcp_z"),
  Senescence_doy = c("late_summer_prcp_z", "early_fall_mean_tmax_z"),
  Dormancy_doy = c("fall_cumulative_prcp_z", "fall_mean_tmax_z"),
  DER.pos_doy = c("late_spring_cumulative_prcp_z", "spring_temp_z"),
  growing_season = c("irrigated_90m_z", "late_summer_prcp_z", "summer_temp_z")
)

# Function to test model assumptions
test_assumptions <- function(model) {
  # Get residuals and fitted values
  resid <- residuals(model)
  fitted_vals <- fitted(model)
  
  # 1. Normality of residuals (Shapiro-Wilk test)
  # Note: Shapiro test limited to n <= 5000
  if (length(resid) <= 5000) {
    shapiro_test <- shapiro.test(resid)
    normality_p <- shapiro_test$p.value
  } else {
    # Use Kolmogorov-Smirnov for large samples
    ks_test <- ks.test(resid, "pnorm", mean(resid), sd(resid))
    normality_p <- ks_test$p.value
  }
  
  # 2. Homoscedasticity (Breusch-Pagan test)
  # Test if variance of residuals is constant
  # We'll use a simple test: correlation between |residuals| and fitted values
  bp_cor <- cor.test(abs(resid), fitted_vals)
  homoscedasticity_p <- bp_cor$p.value
  
  # 3. Normality of random effects
  ranef_vals <- unlist(ranef(model))
  if (length(ranef_vals) > 3 && length(ranef_vals) <= 5000) {
    ranef_shapiro <- shapiro.test(ranef_vals)
    ranef_normality_p <- ranef_shapiro$p.value
  } else if (length(ranef_vals) > 5000) {
    ranef_ks <- ks.test(ranef_vals, "pnorm", mean(ranef_vals), sd(ranef_vals))
    ranef_normality_p <- ranef_ks$p.value
  } else {
    ranef_normality_p <- NA
  }
  
  # 4. Check for outliers (standardized residuals > 3)
  std_resid <- resid / sd(resid)
  n_outliers <- sum(abs(std_resid) > 3)
  prop_outliers <- n_outliers / length(resid)
  
  return(list(
    normality_p = normality_p,
    homoscedasticity_p = homoscedasticity_p,
    ranef_normality_p = ranef_normality_p,
    n_outliers = n_outliers,
    prop_outliers = prop_outliers,
    pass_normality = normality_p > 0.05,
    pass_homoscedasticity = homoscedasticity_p > 0.05,
    pass_ranef_normality = ifelse(is.na(ranef_normality_p), TRUE, ranef_normality_p > 0.05)
  ))
}

# K-fold CV function (same as before)
cv_lmer_both <- function(formula_str, data, k = 10, response_var) {
  set.seed(123)
  folds <- createFolds(1:nrow(data), k = k, returnTrain = FALSE)
  
  predictions_conditional <- numeric(nrow(data))
  predictions_marginal <- numeric(nrow(data))
  
  for(fold_idx in 1:length(folds)) {
    test_idx <- folds[[fold_idx]]
    train_data <- data[-test_idx, ]
    test_data <- data[test_idx, ]
    
    model <- tryCatch({
      lmer(as.formula(formula_str), 
           data = train_data, 
           REML = FALSE)
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(model)) {
      predictions_conditional[test_idx] <- predict(model, newdata = test_data,
                                                   allow.new.levels = TRUE)
      predictions_marginal[test_idx] <- predict(model, newdata = test_data, 
                                                re.form = NA)
    } else {
      predictions_conditional[test_idx] <- NA
      predictions_marginal[test_idx] <- NA
    }
  }
  
  actual <- data[[response_var]]
  valid_idx <- !is.na(predictions_conditional) & !is.na(predictions_marginal) & !is.na(actual)
  
  if (sum(valid_idx) > 0) {
    cv_r2_conditional <- cor(actual[valid_idx], predictions_conditional[valid_idx])^2
    rmse_conditional <- sqrt(mean((actual[valid_idx] - predictions_conditional[valid_idx])^2))
    
    cv_r2_marginal <- cor(actual[valid_idx], predictions_marginal[valid_idx])^2
    rmse_marginal <- sqrt(mean((actual[valid_idx] - predictions_marginal[valid_idx])^2))
  } else {
    cv_r2_conditional <- cv_r2_marginal <- NA
    rmse_conditional <- rmse_marginal <- NA
  }
  
  return(list(
    cv_r2_conditional = cv_r2_conditional,
    cv_r2_marginal = cv_r2_marginal,
    rmse_conditional = rmse_conditional,
    rmse_marginal = rmse_marginal
  ))
}

# Store results
model_results <- list()

for (i in pheno_vars) {
  for (j in species_list) {
    
    cat("\nFitting", i, "for", j, "...\n")
    
    # Prepare data for this species
    data <- tree_ldc_metrics_climate %>% 
      filter(species_common == j, year <= 2024) %>% 
      mutate(
        late_winter_temp_z = scale(late_winter_temp)[,1],
        late_winter_prcp_z = scale(late_winter_prcp)[,1],
        late_spring_mean_tmax_z = scale(late_spring_mean_tmax)[,1],
        spring_prcp_z = scale(spring_prcp)[,1],
        late_summer_prcp_z = scale(late_summer_prcp)[,1],
        early_fall_mean_tmax_z = scale(early_fall_mean_tmax)[,1],
        fall_cumulative_prcp_z = scale(fall_cumulative_prcp)[,1],
        fall_mean_tmax_z = scale(fall_mean_tmax)[,1],
        late_spring_cumulative_prcp_z = scale(late_spring_cumulative_prcp)[,1],
        spring_temp_z = scale(spring_temp)[,1],
        irrigated_90m_z = scale(irrigated_90m)[,1],
        summer_temp_z = scale(summer_temp)[,1],
        late_summer_prcp_z = scale(late_summer_prcp)[,1]
      )
    
    if (nrow(data) < 20 || sum(!is.na(data[[i]])) < 20) {
      cat("  Skipping - insufficient data\n")
      next
    }
    
    predictors <- climate_vars[[i]]
    formula_str <- paste(i, "~", paste(predictors, collapse = " + "), "+ (1 | UID)")
    
    # Fit full model
    full_model <- tryCatch({
      lmer(as.formula(formula_str), 
           data = data, 
           REML = TRUE)
    }, error = function(e) {
      message(paste("  Error fitting model:", e$message))
      return(NULL)
    })
    
    # Run k-fold CV
    cv_results <- tryCatch({
      cv_lmer_both(formula_str, data, k = 10, response_var = i)
    }, error = function(e) {
      message(paste("  Error in CV:", e$message))
      return(NULL)
    })
    
    # Test assumptions
    assumptions <- tryCatch({
      test_assumptions(full_model)
    }, error = function(e) {
      message(paste("  Error testing assumptions:", e$message))
      return(NULL)
    })
    
    # Store results
    if (!is.null(full_model) && !is.null(cv_results) && !is.null(assumptions)) {
      library(MuMIn)
      r2_insample <- r.squaredGLMM(full_model)
      
      model_results[[paste(j, i, sep = "_")]] <- list(
        species = j,
        phenology = i,
        n_obs = nrow(data),
        n_trees = n_distinct(data$UID),
        model = full_model,
        summary = summary(full_model),
        r2m_insample = r2_insample[1, "R2m"],
        r2c_insample = r2_insample[1, "R2c"],
        cv_r2_marginal = cv_results$cv_r2_marginal,
        cv_r2_conditional = cv_results$cv_r2_conditional,
        cv_rmse_marginal = cv_results$rmse_marginal,
        cv_rmse_conditional = cv_results$rmse_conditional,
        # Assumption test results
        normality_p = assumptions$normality_p,
        homoscedasticity_p = assumptions$homoscedasticity_p,
        ranef_normality_p = assumptions$ranef_normality_p,
        n_outliers = assumptions$n_outliers,
        prop_outliers = assumptions$prop_outliers,
        pass_normality = assumptions$pass_normality,
        pass_homoscedasticity = assumptions$pass_homoscedasticity,
        pass_ranef_normality = assumptions$pass_ranef_normality
      )
      
      cat("  CV R²m:", round(cv_results$cv_r2_marginal, 3), 
          "| R²c:", round(cv_results$cv_r2_conditional, 3), "\n")
      cat("  Assumptions: Normality p =", round(assumptions$normality_p, 3),
          "| Homoscedasticity p =", round(assumptions$homoscedasticity_p, 3), "\n")
    }
  }
}

```

## Summarize and Results

### R2, RMSE and Testing model assumptions for all the regression models

```{r}

results_table <- map_df(model_results, function(x) {
  data.frame(
    species = x$species,
    phenology = x$phenology,
    n_obs = x$n_obs,
    n_trees = x$n_trees,
    # R² metrics
    r2m_insample = x$r2m_insample,
    r2c_insample = x$r2c_insample,
    cv_r2_marginal = x$cv_r2_marginal,
    cv_r2_conditional = x$cv_r2_conditional,
    # RMSE
    cv_rmse_marginal = x$cv_rmse_marginal,
    cv_rmse_conditional = x$cv_rmse_conditional,
    # Random effect contribution
    random_effect_contribution = x$cv_r2_conditional - x$cv_r2_marginal,
    # Assumption tests
    normality_p = x$normality_p,
    homoscedasticity_p = x$homoscedasticity_p,
    ranef_normality_p = x$ranef_normality_p,
    n_outliers = x$n_outliers,
    prop_outliers = x$prop_outliers,
    # Pass/fail flags
    pass_normality = x$pass_normality,
    pass_homoscedasticity = x$pass_homoscedasticity,
    pass_ranef_normality = x$pass_ranef_normality,
    # Overall assessment
    all_assumptions_met = x$pass_normality & x$pass_homoscedasticity & x$pass_ranef_normality,
    row.names = NULL
  )
})

results_table

```

### Breakdown by Table by Species or phenological metric

```{r}

# R² comparison - faceted by phenology
results_table %>%
  select(species, phenology, cv_r2_marginal, cv_r2_conditional) %>%
  mutate(random_effect_contribution = cv_r2_conditional - cv_r2_marginal) %>%
  pivot_longer(cols = starts_with("cv_r2"), 
               names_to = "type", 
               values_to = "r2") %>%
  mutate(type = ifelse(type == "cv_r2_marginal", "Marginal (Climate only)", 
                       "Conditional (Climate + Tree ID)")) %>%
  ggplot(aes(x = reorder(species, random_effect_contribution), y = r2, fill = type)) +
  geom_col(position = "dodge") +
  coord_flip() +
  facet_wrap(~phenology, scales = "free_y", ncol = 2) +
  scale_fill_manual(values = c("Marginal (Climate only)" = "coral", 
                                "Conditional (Climate + Tree ID)" = "steelblue")) +
  labs(title = "Cross-Validated R²: Climate vs Climate + Tree Identity",
       subtitle = "Species ordered by tree identity contribution (gap size)",
       x = "", y = "CV R²", fill = "") +
  theme_minimal() +
  theme(legend.position = "top",
        axis.text.y = element_text(size = 8))

# RMSE comparison - faceted by phenology
results_table %>%
  select(species, phenology, cv_rmse_marginal, cv_rmse_conditional) %>%
  pivot_longer(cols = starts_with("cv_rmse"), 
               names_to = "type", 
               values_to = "rmse") %>%
  mutate(type = ifelse(type == "cv_rmse_marginal", "Marginal", "Conditional")) %>%
  ggplot(aes(x = reorder(species, -rmse), y = rmse, fill = type)) +
  geom_col(position = "dodge") +
  coord_flip() +
  facet_wrap(~phenology, scales = "free_y", ncol = 2) +
  scale_fill_manual(values = c("Marginal" = "coral", 
                                "Conditional" = "steelblue")) +
  labs(title = "Cross-Validated RMSE: Average Prediction Error",
       subtitle = "By phenology stage",
       x = "", y = "RMSE (days)", fill = "") +
  theme_minimal() +
  theme(legend.position = "top",
        axis.text.y = element_text(size = 8))

# R² comparison - faceted by species
results_table %>%
  select(species, phenology, cv_r2_marginal, cv_r2_conditional) %>%
  pivot_longer(cols = starts_with("cv_r2"), 
               names_to = "type", 
               values_to = "r2") %>%
  mutate(type = ifelse(type == "cv_r2_marginal", "Marginal (Climate only)", 
                       "Conditional (Climate + Tree ID)")) %>%
  ggplot(aes(x = phenology, y = r2, fill = type)) +
  geom_col(position = "dodge") +
  coord_flip() +
  facet_wrap(~species, scales = "free_y", ncol = 3) +
  scale_fill_manual(values = c("Marginal (Climate only)" = "coral", 
                                "Conditional (Climate + Tree ID)" = "steelblue")) +
  labs(title = "Cross-Validated R²: Climate vs Climate + Tree Identity",
       subtitle = "By species",
       x = "", y = "CV R²", fill = "") +
  theme_minimal() +
  theme(legend.position = "top",
        axis.text.y = element_text(size = 9))

```

```{r}

# Safer version with error checking
check_model_visually <- function(species_name, pheno_var) {
  model_name <- paste(species_name, pheno_var, sep = "_")
  
  # Check if model exists
  if (!model_name %in% names(model_results)) {
    cat("Model not found:", model_name, "\n")
    cat("Available models:", head(names(model_results)), "\n")
    return(NULL)
  }
  
  model <- model_results[[model_name]]$model
  
  # Check if model is valid
  if (is.null(model)) {
    cat("Model is NULL for:", model_name, "\n")
    return(NULL)
  }
  
  # Get residuals and fitted values
  resid <- residuals(model)
  fitted_vals <- fitted(model)
  
  # Check if we have valid data
  if (length(resid) == 0 || all(is.na(resid))) {
    cat("No valid residuals for:", model_name, "\n")
    return(NULL)
  }
  
  par(mfrow = c(2, 2), mar = c(4, 4, 2, 1))
  
  # 1. Q-Q plot (normality)
  qqnorm(resid, main = paste(species_name, "-", pheno_var, "\nQ-Q Plot"),
         pch = 16, col = rgb(0,0,0,0.2))
  qqline(resid, col = "red", lwd = 2)
  
  # 2. Residuals vs Fitted (homoscedasticity)
  plot(fitted_vals, resid,
       main = "Residuals vs Fitted",
       xlab = "Fitted", ylab = "Residuals",
       pch = 16, col = rgb(0,0,0,0.2))
  abline(h = 0, col = "red", lwd = 2)
  lowess_fit <- lowess(fitted_vals, resid)
  lines(lowess_fit, col = "blue", lwd = 2)
  
  # 3. Scale-Location (homoscedasticity)
  plot(fitted_vals, sqrt(abs(resid)),
       main = "Scale-Location",
       xlab = "Fitted", ylab = "√|Residuals|",
       pch = 16, col = rgb(0,0,0,0.2))
  lowess_fit2 <- lowess(fitted_vals, sqrt(abs(resid)))
  lines(lowess_fit2, col = "blue", lwd = 2)
  
  # 4. Histogram of residuals
  hist(resid, breaks = 30, main = "Residual Distribution",
       xlab = "Residuals", col = "lightblue")
  curve(dnorm(x, mean = mean(resid), sd = sd(resid)) * length(resid) * diff(range(resid))/30,
        add = TRUE, col = "red", lwd = 2)
  
  par(mfrow = c(1, 1))
  
  # Print summary stats
  cat("\n=== Diagnostics for", species_name, "-", pheno_var, "===\n")
  cat("Sample size:", length(resid), "\n")
  cat("Residual range:", round(range(resid), 2), "\n")
  cat("Residual SD:", round(sd(resid), 2), "\n")
  cat("Shapiro p-value:", format(results_table %>% 
                                   filter(species == species_name, phenology == pheno_var) %>% 
                                   pull(normality_p), scientific = TRUE), "\n\n")
}

# Get worst 5 models
worst_5 <- results_table %>%
  arrange(normality_p) %>%
  head(5)

print(worst_5 %>% select(species, phenology, normality_p, cv_r2_conditional))

# Check them one by one
for(i in 1:nrow(worst_5)) {
  cat("\n\n========== Model", i, "of", nrow(worst_5), "==========\n")
  check_model_visually(worst_5$species[i], worst_5$phenology[i])
  
  if (i < nrow(worst_5)) {
    response <- readline(prompt = "Press [enter] for next plot, or 'q' to quit: ")
    if (tolower(response) == 'q') break
  }
}

```

# Generalized Additive Mixed Model

```{r}

# Function to fit GAMM with CV for one species
fit_gamm_with_cv <- function(species_name, pheno_var, climate_predictors, data) {
  
  # Prepare data
  gamm_data <- data %>%
    filter(species_common == species_name, year < 2025) %>%
    select(all_of(c(pheno_var, "UID", climate_predictors))) 
  
  # Check sample size
  if (nrow(gamm_data) < 20) {
    return(NULL)
  }
  
  # Build formula with smooth terms
smooth_terms <- paste0("s(", climate_predictors, ", k = 6)", collapse = " + ")
formula_str <- paste(pheno_var, "~", smooth_terms, "+ s(UID, bs = 're')")
  
  cat("\nFitting:", species_name, "-", pheno_var)
  cat("\nFormula:", formula_str, "\n")
  
  # Fit full model
  full_model <- bam(
    as.formula(formula_str),
    data = gamm_data,
    method = "REML"
  )
  
  # Cross-validation
  set.seed(123)
  folds <- createFolds(1:nrow(gamm_data), k = 10, returnTrain = FALSE)
  
  predictions <- numeric(nrow(gamm_data))
  
  for(fold_idx in 1:length(folds)) {
    test_idx <- folds[[fold_idx]]
    train_data <- gamm_data[-test_idx, ]
    test_data <- gamm_data[test_idx, ]
    
    # Fit model on training fold
    cv_model <- tryCatch({
      bam(as.formula(formula_str),
          data = train_data,
          method = "REML")
    }, error = function(e) {
      return(NULL)
    })
    
    if (!is.null(cv_model)) {
      predictions[test_idx] <- predict(cv_model, newdata = test_data)
    } else {
      predictions[test_idx] <- NA
    }
  }
  
  # Calculate CV metrics
  actual <- gamm_data[[pheno_var]]
  valid_idx <- !is.na(predictions) & !is.na(actual)
  
  if (sum(valid_idx) > 0) {
    cv_r2 <- cor(actual[valid_idx], predictions[valid_idx])^2
    cv_rmse <- sqrt(mean((actual[valid_idx] - predictions[valid_idx])^2))
  } else {
    cv_r2 <- cv_rmse <- NA
  }
  
  cat("CV R²:", round(cv_r2, 3), "| RMSE:", round(cv_rmse, 2), "\n")
  
  return(list(
    species = species_name,
    phenology = pheno_var,
    n_obs = nrow(gamm_data),
    n_trees = n_distinct(gamm_data$UID),
    model = full_model,
    cv_r2 = cv_r2,
    cv_rmse = cv_rmse,
    predictions = predictions,
    actual = actual
  ))
}

# Define climate variables (same as before)
climate_vars <- list(
  Greenup_doy = c("late_winter_temp", "late_winter_prcp", "impervious_90m"),
  Maturity_doy = c("late_spring_mean_tmax", "spring_prcp",  "impervious_90m"),
  Senescence_doy = c("late_summer_prcp", "early_fall_mean_tmax", "impervious_90m"),
  Dormancy_doy = c("fall_cumulative_prcp", "fall_mean_tmax", "impervious_90m"),
  DER.pos_doy = c("late_spring_cumulative_prcp", "spring_temp", "impervious_90m"),
  growing_season = c("impervious_90m", "late_summer_prcp", "summer_temp")
)

# Fit GAMM models
gamm_results <- list()

for (i in pheno_vars) {
  for (j in species_list) {
    
    predictors <- climate_vars[[i]]
    
    result <- tryCatch({
      fit_gamm_with_cv(j, i, predictors, tree_ldc_metrics_climate)
    }, error = function(e) {
      message(paste("Error:", e$message))
      return(NULL)
    })
    
    if (!is.null(result)) {
      gamm_results[[paste(j, i, sep = "_")]] <- result
    }
  }
}

# Extract results
gamm_table <- map_df(gamm_results, function(x) {
  data.frame(
    species = x$species,
    phenology = x$phenology,
    n_obs = x$n_obs,
    n_trees = x$n_trees,
    gamm_cv_r2 = x$cv_r2,
    gamm_cv_rmse = x$cv_rmse,
    row.names = NULL
  )
})

print(gamm_table)

```
## Function to plot smooth effects pheno-metric

```{r}

plot_gamm_smooths <- function(model_name, gamm_results) {
  
  if (!model_name %in% names(gamm_results)) {
    cat("Model not found:", model_name, "\n")
    return(NULL)
  }
  
  model <- gamm_results[[model_name]]$model
  species <- gamm_results[[model_name]]$species
  pheno <- gamm_results[[model_name]]$phenology
  
  # Get smooth terms, excluding random effect
  smooth_labels <- sapply(model$smooth, function(x) x$label)
  predictor_idx <- which(!grepl("UID", smooth_labels))
  n_predictors <- length(predictor_idx)
  
  # Set layout
  if (n_predictors == 2) {
    par(mfrow = c(1, 2))
  } else if (n_predictors <= 4) {
    par(mfrow = c(2, 2))
  } else {
    par(mfrow = c(2, 3))
  }
  
  # Plot smooths
  for (i in 1:n_predictors) {
    idx <- predictor_idx[i]
    predictor_name <- model$smooth[[idx]]$term
    
    plot(model, 
         select = idx, 
         shade = TRUE, 
         main = if(i == 1) paste(species, "-", pheno) else "",
         xlab = predictor_name, 
         ylab = "Effect on DOY",
         rug = TRUE)
  }
  
  par(mfrow = c(1, 1))
  
  # Print summary
  print(summary(model))
}

# Usage
plot_gamm_smooths("Silver Maple_Dormancy_doy", gamm_results)

```

## COMPARE GAMM vs MIXED MODEL

```{r}

# Merge results
comparison <- results_table %>%
  select(species, phenology, 
         mixed_cv_r2 = cv_r2_conditional, 
         mixed_cv_rmse = cv_rmse_conditional) %>%
  left_join(gamm_table, by = c("species", "phenology")) %>%
  mutate(
    gamm_improvement = gamm_cv_r2 - mixed_cv_r2,
    rmse_improvement = mixed_cv_rmse - gamm_cv_rmse,  # Positive = GAMM better
    gamm_wins = gamm_cv_r2 > mixed_cv_r2
  )

# Summary statistics
cat("\n=== GAMM vs Mixed Model Comparison ===\n")
cat("Total models:", nrow(comparison), "\n")
cat("GAMM wins:", sum(comparison$gamm_wins, na.rm = TRUE), 
    "out of", sum(!is.na(comparison$gamm_wins)), "\n")
cat("\nMean CV R²:\n")
cat("  Mixed Model:", round(mean(comparison$mixed_cv_r2, na.rm = TRUE), 3), "\n")
cat("  GAMM:       ", round(mean(comparison$gamm_cv_r2, na.rm = TRUE), 3), "\n")
cat("\nMean R² improvement:", round(mean(comparison$gamm_improvement, na.rm = TRUE), 3), "\n")
cat("Mean RMSE improvement:", round(mean(comparison$rmse_improvement, na.rm = TRUE), 2), "days\n")

# Save comparison
write.csv(comparison, "gamm_vs_mixed_comparison.csv", row.names = FALSE)

# ============================================================================
# VISUALIZATIONS
# ============================================================================

library(ggplot2)
library(tidyr)

# 1. Boxplot comparison
comparison %>%
  select(species, phenology, mixed_cv_r2, gamm_cv_r2) %>%
  pivot_longer(cols = ends_with("_r2"),
               names_to = "method",
               values_to = "cv_r2") %>%
  mutate(method = ifelse(method == "mixed_cv_r2", "Mixed Model", "GAMM")) %>%
  ggplot(aes(x = method, y = cv_r2, fill = method)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.3, size = 1) +
  scale_fill_manual(values = c("Mixed Model" = "steelblue", "GAMM" = "forestgreen")) +
  labs(title = "Cross-Validated R²: Mixed Model vs GAMM",
       subtitle = paste(nrow(comparison), "models across 12 species and 6 phenology stages"),
       x = "Method",
       y = "CV R²") +
  theme_minimal() +
  theme(legend.position = "none")

ggsave("gamm_vs_mixed_boxplot.png", width = 8, height = 6, dpi = 300)

# 2. Scatter plot
comparison %>%
  ggplot(aes(x = mixed_cv_r2, y = gamm_cv_r2)) +
  geom_point(aes(color = phenology), size = 3, alpha = 0.7) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray50") +
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  labs(title = "GAMM vs Mixed Model Performance",
       subtitle = "Points above line = GAMM outperforms",
       x = "Mixed Model CV R²",
       y = "GAMM CV R²",
       color = "Phenology") +
  coord_fixed(xlim = c(0, 1), ylim = c(0, 1)) +
  theme_minimal()

ggsave("gamm_vs_mixed_scatter.png", width = 10, height = 8, dpi = 300)

# 3. Improvement histogram
comparison %>%
  ggplot(aes(x = gamm_improvement)) +
  geom_histogram(fill = "forestgreen", alpha = 0.7, bins = 20) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 1) +
  labs(title = "GAMM Improvement over Mixed Models",
       subtitle = "Positive values = GAMM better | Red line = no difference",
       x = "ΔR² (GAMM - Mixed Model)",
       y = "Count") +
  theme_minimal()

ggsave("gamm_improvement_histogram.png", width = 8, height = 6, dpi = 300)

# 4. By phenology stage
comparison %>%
  group_by(phenology) %>%
  summarise(
    mean_mixed = mean(mixed_cv_r2, na.rm = TRUE),
    mean_gamm = mean(gamm_cv_r2, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  pivot_longer(cols = starts_with("mean_"),
               names_to = "method",
               values_to = "mean_r2") %>%
  mutate(method = ifelse(method == "mean_mixed", "Mixed Model", "GAMM")) %>%
  ggplot(aes(x = phenology, y = mean_r2, fill = method)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = c("Mixed Model" = "steelblue", "GAMM" = "forestgreen")) +
  labs(title = "Mean CV R² by Phenology Stage",
       x = "Phenology Stage",
       y = "Mean CV R²",
       fill = "Method") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("mean_r2_by_phenology.png", width = 10, height = 6, dpi = 300)

# 5. Top improvements
cat("\n=== Top 10 Models Where GAMM Improves Most ===\n")
comparison %>%
  arrange(desc(gamm_improvement)) %>%
  head(10) %>%
  select(species, phenology, mixed_cv_r2, gamm_cv_r2, gamm_improvement) %>%
  print()

# 6. Models where Mixed Model wins
cat("\n=== Models Where Mixed Model Wins ===\n")
comparison %>%
  filter(!gamm_wins) %>%
  arrange(gamm_improvement) %>%
  select(species, phenology, mixed_cv_r2, gamm_cv_r2, gamm_improvement) %>%
  print()

# ============================================================================
# VISUALIZE SMOOTH EFFECTS FOR KEY MODELS
# ============================================================================

# Function to plot smooth effects
plot_gamm_smooths <- function(model_name) {
  
  if (!model_name %in% names(gamm_results)) {
    cat("Model not found:", model_name, "\n")
    return(NULL)
  }
  
  model <- gamm_results[[model_name]]$model
  species <- gamm_results[[model_name]]$species
  pheno <- gamm_results[[model_name]]$phenology
  
  # Create filename
  filename <- paste0(gsub(" ", "_", tolower(species)), "_", 
                    tolower(pheno), "_smooths.png")
  
  # Save plot
  png(filename, width = 10, height = 5, units = "in", res = 300)
  par(mfrow = c(1, 2), mar = c(4, 4, 3, 1))
  
  # Plot each smooth
  plot(model, select = 1, shade = TRUE, shade.col = "lightgreen",
       main = paste(species, "-", pheno),
       xlab = names(model$smooth)[1], 
       ylab = "Effect on DOY (days)",
       cex.main = 1)
  
  plot(model, select = 2, shade = TRUE, shade.col = "lightblue",
       main = "",
       xlab = names(model$smooth)[2],
       ylab = "Effect on DOY (days)")
  
  par(mfrow = c(1, 1))
  dev.off()
  
  cat("Saved:", filename, "\n")
}

# Plot for Tree of Heaven
cat("\n=== Creating smooth plots for key models ===\n")
if ("Tree of heaven_Greenup_doy" %in% names(gamm_results)) {
  plot_gamm_smooths("Tree of heaven_Greenup_doy")
}

# Plot for best improvement models
top_improvements <- comparison %>%
  arrange(desc(gamm_improvement)) %>%
  head(3)

for(i in 1:nrow(top_improvements)) {
  model_name <- paste(top_improvements$species[i], 
                     top_improvements$phenology[i], sep = "_")
  if (model_name %in% names(gamm_results)) {
    plot_gamm_smooths(model_name)
  }
}

cat("\n=== Analysis Complete! ===\n")
cat("Files created:\n")
cat("  - gamm_cv_results.csv\n")
cat("  - gamm_vs_mixed_comparison.csv\n")
cat("  - gamm_vs_mixed_boxplot.png\n")
cat("  - gamm_vs_mixed_scatter.png\n")
cat("  - gamm_improvement_histogram.png\n")
cat("  - mean_r2_by_phenology.png\n")
cat("  - [species]_[phenology]_smooths.png (multiple files)\n")

```

```{r}

# Function to tune k parameter with CV
tune_gamm_k <- function(species_name, pheno_var, climate_predictors, data, 
                        k_values = c(3, 4, 5, 6), cv_folds = 10) {
  
  # Prepare data
  gamm_data <- data %>%
    filter(species_common == species_name, year < 2024) %>%
    select(all_of(c(pheno_var, "UID", climate_predictors)))
  
  # Check sample size
  if (nrow(gamm_data) < 20) {
    return(NULL)
  }
  
  cat("\nTuning k for:", species_name, "-", pheno_var, "\n")
  
  # Set up CV folds once
  set.seed(123)
  folds <- createFolds(1:nrow(gamm_data), k = cv_folds, returnTrain = FALSE)
  
  # Storage for results
  k_results <- data.frame(
    k = integer(),
    cv_r2 = numeric(),
    cv_rmse = numeric(),
    aic = numeric(),
    edf = numeric()
  )
  
  # Try each k value
  for (k_val in k_values) {
    
    # Build formula with current k
    smooth_terms <- paste0("s(", climate_predictors, ", k = ", k_val, ")", 
                          collapse = " + ")
    formula_str <- paste(pheno_var, "~", smooth_terms, "+ s(UID, bs = 're')")
    
    # Try fitting full model first to check feasibility
    full_model <- tryCatch({
      bam(as.formula(formula_str), data = gamm_data, method = "REML")
    }, error = function(e) {
      NULL
    })
    
    if (is.null(full_model)) {
      cat("  k =", k_val, ": Failed to fit\n")
      next
    }
    
    # Cross-validation
    predictions <- numeric(nrow(gamm_data))
    
    for(fold_idx in 1:length(folds)) {
      test_idx <- folds[[fold_idx]]
      train_data <- gamm_data[-test_idx, ]
      test_data <- gamm_data[test_idx, ]
      
      cv_model <- tryCatch({
        bam(as.formula(formula_str), data = train_data, method = "REML")
      }, error = function(e) NULL)
      
      if (!is.null(cv_model)) {
        predictions[test_idx] <- predict(cv_model, newdata = test_data)
      } else {
        predictions[test_idx] <- NA
      }
    }
    
    # Calculate CV metrics
    actual <- gamm_data[[pheno_var]]
    valid_idx <- !is.na(predictions) & !is.na(actual)
    
    if (sum(valid_idx) > 0) {
      cv_r2 <- cor(actual[valid_idx], predictions[valid_idx])^2
      cv_rmse <- sqrt(mean((actual[valid_idx] - predictions[valid_idx])^2))
    } else {
      cv_r2 <- cv_rmse <- NA
    }
    
    # Get model info
    aic_val <- AIC(full_model)
    total_edf <- sum(full_model$edf)
    
    k_results <- rbind(k_results, data.frame(
      k = k_val,
      cv_r2 = cv_r2,
      cv_rmse = cv_rmse,
      aic = aic_val,
      edf = total_edf
    ))
    
    cat("  k =", k_val, "| CV R² =", round(cv_r2, 3), 
        "| RMSE =", round(cv_rmse, 2), 
        "| AIC =", round(aic_val, 1), "\n")
  }
  
  # Select best k (prioritize CV R², but check for overfitting)
  if (nrow(k_results) > 0) {
    # Remove rows with NA
    k_results <- k_results[complete.cases(k_results), ]
    
    # Select best by CV R²
    best_k <- k_results$k[which.max(k_results$cv_r2)]
    
    cat("  → Best k:", best_k, "\n")
    
    return(list(
      best_k = best_k,
      k_results = k_results
    ))
  } else {
    return(NULL)
  }
}

# Modified fitting function using tuned k
fit_gamm_with_tuned_k <- function(species_name, pheno_var, climate_predictors, 
                                   data, k_values = c(3, 4, 5, 6)) {
  
  # First tune k
  tune_result <- tune_gamm_k(species_name, pheno_var, climate_predictors, 
                             data, k_values)
  
  if (is.null(tune_result)) {
    return(NULL)
  }
  
  best_k <- tune_result$best_k
  
  # Prepare data
  gamm_data <- data %>%
    filter(species_common == species_name, year < 2024) %>%
    select(all_of(c(pheno_var, "UID", climate_predictors)))
  
  # Build formula with best k #"tp", "cr", "cs"
  smooth_terms <- paste0("s(", climate_predictors,", bs = tp", ", k = ", best_k, ")", 
                        collapse = " + ")
  formula_str <- paste(pheno_var, "~", smooth_terms, "+ s(UID, bs = 're')")
  
  # Fit final model
  full_model <- bam(as.formula(formula_str), data = gamm_data, method = "REML")
  
  # Get best CV metrics from tuning
  best_metrics <- tune_result$k_results[tune_result$k_results$k == best_k, ]
  
  return(list(
    species = species_name,
    phenology = pheno_var,
    n_obs = nrow(gamm_data),
    n_trees = n_distinct(gamm_data$UID),
    model = full_model,
    best_k = best_k,
    cv_r2 = best_metrics$cv_r2,
    cv_rmse = best_metrics$cv_rmse,
    k_tuning_results = tune_result$k_results
  ))
}

```

```{r}
tune_gamm_comprehensive <- function(species_name, pheno_var, climate_predictors, data) {
  
  gamm_data <- data %>%
    filter(species_common == species_name, year < 2025) %>%
    select(all_of(c(pheno_var, "UID", climate_predictors)))
  
  if (nrow(gamm_data) < 20) return(NULL)
  
  cat("\n=== Tuning:", species_name, "-", pheno_var, "===\n")
  
  # Parameter grid
  param_grid <- expand.grid(
    k = c(3, 4, 5, 6),
    bs = c("tp", "cr", "cs"),
    interaction = c(FALSE, TRUE),
    stringsAsFactors = FALSE
  )
  
  set.seed(123)
  folds <- createFolds(1:nrow(gamm_data), k = 5, returnTrain = FALSE)
  
  results <- data.frame()
  
  for (i in 1:nrow(param_grid)) {
    
    # Build formula
    if (param_grid$interaction[i]) {
      formula_str <- paste0(pheno_var, " ~ te(", 
                           paste(climate_predictors, collapse = ", "),
                           ", k = ", param_grid$k[i], ", bs = '", param_grid$bs[i], 
                           "') + s(UID, bs = 're')")
    } else {
      smooth_terms <- paste0("s(", climate_predictors, 
                            ", k = ", param_grid$k[i], 
                            ", bs = '", param_grid$bs[i], "')", 
                            collapse = " + ")
      formula_str <- paste(pheno_var, "~", smooth_terms, "+ s(UID, bs = 're')")
    }
    
    # CV
    predictions <- numeric(nrow(gamm_data))
    
    for(fold_idx in 1:length(folds)) {
      test_idx <- folds[[fold_idx]]
      train_data <- gamm_data[-test_idx, ]
      test_data <- gamm_data[test_idx, ]
      
      cv_model <- tryCatch({
        bam(as.formula(formula_str), data = train_data, method = "REML")
      }, error = function(e) NULL)
      
      if (!is.null(cv_model)) {
        predictions[test_idx] <- predict(cv_model, newdata = test_data)
      } else {
        predictions[test_idx] <- NA
      }
    }
    
    actual <- gamm_data[[pheno_var]]
    valid_idx <- !is.na(predictions) & !is.na(actual)
    
    if (sum(valid_idx) > 10) {
      cv_r2 <- cor(actual[valid_idx], predictions[valid_idx])^2
      cv_rmse <- sqrt(mean((actual[valid_idx] - predictions[valid_idx])^2))
      
      # Fit full model for AIC
      full_model <- tryCatch({
        bam(as.formula(formula_str), data = gamm_data, method = "REML")
      }, error = function(e) NULL)
      
      if (!is.null(full_model)) {
        results <- rbind(results, data.frame(
          k = param_grid$k[i],
          bs = param_grid$bs[i],
          interaction = param_grid$interaction[i],
          cv_r2 = cv_r2,
          cv_rmse = cv_rmse,
          aic = AIC(full_model),
          edf = sum(full_model$edf)
        ))
      }
    }
  }
  
  if (nrow(results) > 0) {
    results <- results[order(-results$cv_r2), ]
    cat("\nTop 5 configurations:\n")
    print(head(results, 5))
    
    return(list(
      best_params = results[1, ],
      all_results = results
    ))
  } else {
    return(NULL)
  }
}

```

```{r}

tuning_result <- tune_gamm_comprehensive(
  "Green Ash", 
  "Greenup_doy", 
  c("late_winter_temp", "late_winter_prcp"),
  tree_ldc_metrics_climate
)

```
## Checking Assumptions 

```{r}

# Comprehensive GAMM diagnostics
check_gamm_assumptions <- function(model, model_data, model_name = "") {
  
  cat("\n======================================\n")
  cat("GAMM Diagnostics:", model_name, "\n")
  cat("======================================\n\n")
  
  # Basic gam.check (gives residual plots and k' test)
  cat("1. Basic GAM diagnostics:\n")
  gam.check(model)
  
  # Extract residuals and fitted values
  resid <- residuals(model, type = "deviance")
  fitted <- fitted(model)
  
  # Set up plotting grid
  par(mfrow = c(2, 3))
  
  # 1. Residuals vs Fitted (homoscedasticity)
  plot(fitted, resid,
       xlab = "Fitted values", ylab = "Residuals",
       main = "Residuals vs Fitted")
  abline(h = 0, col = "red", lty = 2)
  lines(lowess(fitted, resid), col = "blue", lwd = 2)
  
  # 2. Q-Q plot (normality of residuals)
  qqnorm(resid, main = "Normal Q-Q Plot")
  qqline(resid, col = "red")
  
  # 3. Scale-Location (homoscedasticity)
  plot(fitted, sqrt(abs(resid)),
       xlab = "Fitted values", ylab = "√|Residuals|",
       main = "Scale-Location")
  lines(lowess(fitted, sqrt(abs(resid))), col = "blue", lwd = 2)
  
  # 4. Histogram of residuals (normality)
  hist(resid, breaks = 30, freq = FALSE,
       main = "Residual Distribution",
       xlab = "Residuals")
  curve(dnorm(x, mean = mean(resid), sd = sd(resid)), 
        add = TRUE, col = "red", lwd = 2)
  
  # 5. Residuals vs Index (independence)
  plot(1:length(resid), resid,
       xlab = "Observation Order", ylab = "Residuals",
       main = "Residuals vs Order")
  abline(h = 0, col = "red", lty = 2)
  
  # 6. ACF of residuals (temporal correlation)
  acf(resid, main = "ACF of Residuals")
  
  par(mfrow = c(1, 1))
  
  # Statistical tests
  cat("\n2. Statistical Tests:\n")
  
  # Shapiro-Wilk test for normality (if n < 5000)
  if (length(resid) < 5000) {
    shapiro_test <- shapiro.test(resid)
    cat("Shapiro-Wilk normality test: p =", round(shapiro_test$p.value, 4))
    if (shapiro_test$p.value < 0.05) {
      cat(" (FAIL - residuals not normal)\n")
    } else {
      cat(" (PASS)\n")
    }
  }
  
  # Breusch-Pagan test for homoscedasticity
  # Simple version: correlation between squared residuals and fitted values
  bp_test <- cor.test(fitted, resid^2)
  cat("Homoscedasticity test: r =", round(bp_test$estimate, 3), 
      ", p =", round(bp_test$p.value, 4))
  if (bp_test$p.value < 0.05) {
    cat(" (WARNING - possible heteroscedasticity)\n")
  } else {
    cat(" (PASS)\n")
  }
  
  # Check concurvity (multicollinearity for smooths)
  cat("\n3. Concurvity Check (should be < 0.8):\n")
  conc <- concurvity(model, full = FALSE)$estimate
  smooth_labels <- sapply(model$smooth, function(x) x$label)
  predictor_idx <- which(!grepl("UID", smooth_labels))
  
  if (length(predictor_idx) > 1) {
    conc_subset <- conc[predictor_idx, predictor_idx]
    predictor_names <- smooth_labels[predictor_idx]
    rownames(conc_subset) <- colnames(conc_subset) <- predictor_names
    print(round(conc_subset, 3))
    
    # Check for high concurvity
    high_conc <- which(conc_subset > 0.8 & conc_subset < 1, arr.ind = TRUE)
    if (nrow(high_conc) > 0) {
      cat("\nWARNING: High concurvity (>0.8) detected!\n")
    }
  }
  
  # Check k (basis dimension)
  cat("\n4. Basis Dimension Check:\n")
  cat("If k-index < 1.0 or p-value < 0.05, increase k\n")
  k_check <- k.check(model)
  print(k_check)
  
  # Random effects diagnostics
  cat("\n5. Random Effects:\n")
  random_effects <- coef(model)[grepl("UID", names(coef(model)))]
  cat("Number of trees:", length(random_effects), "\n")
  cat("Random effect SD:", round(sd(random_effects), 2), "\n")
  cat("Random effect range:", round(range(random_effects), 2), "\n")
  
  # Plot random effects
  par(mfrow = c(1, 2))
  hist(random_effects, breaks = 20, 
       main = "Random Effects Distribution",
       xlab = "Tree-level intercept adjustment")
  qqnorm(random_effects, main = "Random Effects Q-Q Plot")
  qqline(random_effects, col = "red")
  par(mfrow = c(1, 1))
  
  # Overall summary
  cat("\n======================================\n")
  cat("Summary:\n")
  cat("Model converged:", model$converged, "\n")
  cat("Deviance explained:", round(summary(model)$dev.expl * 100, 1), "%\n")
  cat("R-squared:", round(summary(model)$r.sq, 3), "\n")
  cat("======================================\n\n")
  
  # Return diagnostic metrics
  invisible(list(
    shapiro_p = if(length(resid) < 5000) shapiro_test$p.value else NA,
    homoscedasticity_p = bp_test$p.value,
    max_concurvity = if(length(predictor_idx) > 1) max(conc_subset[conc_subset < 1]) else NA,
    converged = model$converged
  ))
}

# Usage
check_gamm_assumptions(
  gamm_results[["Tree of heaven_DER.pos_doy"]]$model,
  tree_ldc_metrics_climate,
  "Tree of heaven - DER.pos_doy"
)

```

```{r}

# Function to get concurvity metrics for all models
check_all_concurvity <- function(gamm_results) {
  
  concurvity_table <- data.frame()
  
  for (model_name in names(gamm_results)) {
    
    model <- gamm_results[[model_name]]$model
    species <- gamm_results[[model_name]]$species
    pheno <- gamm_results[[model_name]]$phenology
    
    # Get predictor smooths only
    smooth_labels <- sapply(model$smooth, function(x) x$label)
    predictor_idx <- which(!grepl("UID", smooth_labels))
    
    if (length(predictor_idx) > 1) {
      conc <- concurvity(model, full = FALSE)$estimate
      conc_mat <- conc[predictor_idx, predictor_idx]
      
      # Get max concurvity (excluding diagonal)
      diag(conc_mat) <- 0
      max_concurvity <- max(conc_mat)
      
      # Find which pair has max concurvity
      max_idx <- which(conc_mat == max_concurvity, arr.ind = TRUE)[1,]
      predictor_names <- smooth_labels[predictor_idx]
      pair <- paste(predictor_names[max_idx[1]], "<->", predictor_names[max_idx[2]])
      
      # Flag if problematic
      flag <- ifelse(max_concurvity > 0.8, "HIGH", 
                    ifelse(max_concurvity > 0.6, "MODERATE", "OK"))
      
    } else {
      max_concurvity <- NA
      pair <- "Single predictor"
      flag <- "N/A"
    }
    
    concurvity_table <- rbind(concurvity_table, data.frame(
      species = species,
      phenology = pheno,
      n_predictors = length(predictor_idx),
      max_concurvity = round(max_concurvity, 3),
      worst_pair = pair,
      flag = flag,
      r2 = round(summary(model)$r.sq, 3),
      deviance_expl = round(summary(model)$dev.expl, 3)
    ))
  }
  
  return(concurvity_table)
}

# Run for all models
concurvity_results <- check_all_concurvity(gamm_results)

# View results
print(concurvity_results)

# See only problematic models
concurvity_results %>%
  filter(flag == "HIGH") %>%
  arrange(desc(max_concurvity))

# Save to CSV
write.csv(concurvity_results, "gamm_concurvity_check.csv", row.names = FALSE)

```

