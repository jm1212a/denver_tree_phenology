---
title: "Exploratory Analysis"
author: "Jared Martin"
format: html
editor: visual
---

```{r}

library(tidyverse)
library(sf)
library(tigris)
library(gridExtra)
library(leaflet)
library(rstac)
library(terra)
library(tidyterra)

```

```{r}

denver_tree <- read_rds("../data_raw/denver_tree/tree_inventory_denver_20250911.rds")

glimpse(denver_tree)

```

```{r}

denver_county <- counties(state = "CO", cb = TRUE) %>%
  filter(NAME == "Denver") %>%
  st_transform(crs = 4326) # adjust to local projection for final sample

```

```{r}

denver_tree %>%
  # Fix formatting of common names: convert "last, first" to "first last"
  mutate(
    species_common = if_else(
      str_detect(species_common, ","),# check if a comma exists
      str_replace(species_common, "^(.*),\\s*(.*)$", "\\2 \\1"), # swap parts around
      species_common  # leave unchanged if no comma
    ),
    # Combine scientific and common names into one column
    botanic_common = paste(species_botanic, "(", species_common, ")"),
    # Standardize disease/pest field: anything containing "N/A" becomes exactly "N/A"
    disease_pest_def = if_else(str_detect(disease_pest_def, "N/A"), 
                               "N/A", disease_pest_def)
    ) %>%
  filter(species_botanic != "Tree requested") %>% # Remove rows with placeholder species
  # Extract the Genus + species (binomial name) from species_botanic
  mutate(
    species_sci = str_extract(species_botanic, "^[A-Za-z]+\\s+x?\\s?[A-Za-z]+")
  ) %>% 
  filter(!is.na(species_sci)) %>% # Keep only rows with a valid species_sci
  st_as_sf(
    wkt = "the_geom", # column with WKT strings
    crs = 4326        # EPSG:4326 (lon/lat in WGS84) adjust to local projection for final sample
    ) %>%
  st_filter(denver_county) %>%  # filtering out trees that are not with Denver County
  filter(x_long < -104.7302) %>% 
  left_join(read_csv2("../data_raw/dc_trees/dc_tree_species.csv"), 
            by = "species_sci") %>% # loading list of dc tree species
  mutate(dc_tree = case_when(
    is.na(dc_tree) ~ FALSE,  # changing na to false
    .default = dc_tree)) %>% 
  left_join(read_csv2("../data_raw/disease_groups/usda_disease_categories"), 
            by = "disease_pest_def") %>% 
  left_join(read_csv2("../data_raw/tree_leaf_taxanomy/tree_leaf_taxanomy.csv"), 
            by = "species_sci") %>% 
  write_rds("../data_raw/denver_tree/denver_tree_clean.rds")
  
```

To-do List:

1.  Add filter to exclude the 30 trees near the Denver Airport.
2.  Add in the DC Scientific data using code on 52 to 56 to extract only genus and species from DC.
3.  Calculate the % of surfaces around each tree location.
4.  leaflet_satellite backdrop
5.  shinny app \_ filter tree sci_name

-   filter for cluster or points
-   filter size
-   variables selections (for distributions plots)
-   distribution plot (y %total / x lat or long) \* maybe 3d chart

```{r}

denver_tree_sf <- read_rds("../data_raw/denver_tree/denver_tree_clean.rds")

# comment test
leaflet(denver_tree_sf) %>%
  addTiles()%>%
  addPolygons(
    data = denver_county,
    fillOpacity = 0,        # Transparent fill
    color = "red",          # Boundary color
    weight = 2,             # Line thickness
    opacity = 0.8           # Line opacity
  ) %>% 
  addCircleMarkers(
    radius = 3,
    color = "forestgreen",
    stroke = FALSE,
    fillOpacity = 1,
    clusterOptions = markerClusterOptions()
  )

```

# pulling DLUDS form Microsoft planetrycomputing

```{r}

denver_tree_sf <- read_rds("../data_raw/denver_tree/denver_tree_clean.rds")

stac_source <- stac("https://planetarycomputer.microsoft.com/api/stac/v1/")

denver_county <- counties(state = "CO", cb = TRUE) %>%
  filter(NAME == "Denver") %>%
  st_transform(crs = 4326) # adjust to local projection for final sample

stac_query <- stac_search(
  q = stac_source,
  collections = "drcog-lulc",
  intersects = denver_county
)

signed_stac_query <- items_sign(
  post_request(stac_query),
  sign_planetary_computer()
)

class_df <- map_dfr(signed_stac_query$features[[1]]$assets$data$`classification:classes`, as_tibble)

class_df$col <- paste0("#", class_df$color_hint)

write_csv(class_df ,"../data_raw/mis._data_sets/class_df.csv")

```

```{r}

ref_DLCD <- vector("list", length = 93)  # preallocate list

for (i in 1:93) {
  # Load raster
  r <- rast(paste0("/vsicurl/", signed_stac_query$features[[i]]$assets$data$href))
  
  # Get raster corners
  e <- ext(r)
  corners <- vect(rbind(
    c(xmin(e), ymin(e)),
    c(xmin(e), ymax(e)),
    c(xmax(e), ymin(e)),
    c(xmax(e), ymax(e))
  ), crs = crs(r))
  
  corners_ll <- project(corners, "EPSG:4326")
  
  # Store metadata for this raster
  ref_DLCD[[i]] <- data.frame(
    rast_id = paste0("/vsicurl/", signed_stac_query$features[[i]]$assets$data$href),
    xmin = xmin(corners_ll),
    xmax = xmax(corners_ll),
    ymin = ymin(corners_ll),
    ymax = ymax(corners_ll)
  )
}

# Bind list into one data frame
ref_DLCD <- dplyr::bind_rows(ref_DLCD)

write_csv(ref_DLCD ,"../data_raw/mis._data_sets/ref_DLCD.csv")

```


```{r}

stac_query <- stac_search(
  q = stac("https://planetarycomputer.microsoft.com/api/stac/v1/"),
  collections = "drcog-lulc"
  )
  
land_cover <- function(geom) {
  
  ref_DLCD <- read_csv("../data_raw/mis._data_sets/ref_DLCD.csv")
  class_df <- read_csv("../data_raw/mis._data_sets/class_df.csv")
  
  # wrap raw geometry in sfc with CRS
  if (!inherits(geom, "sfc")) {
    geom <- st_sfc(geom, crs = st_crs(denver_tree_sf))
  }
  
  rast_id_match <- NA
  coords <- st_coordinates(geom)[1, ]
  x <- coords[1]; y <- coords[2]
  
  for (i in seq_len(nrow(ref_DLCD))) {
    bbox <- ref_DLCD[i, ]
    if (x >= bbox$xmin && x <= bbox$xmax &&
        y >= bbox$ymin && y <= bbox$ymax) {
      rast_id_match <- bbox$rast_id
      break
    }
  }
  
  r <- rast(rast_id_match)
  
  bufs <- buffer(vect(geom), width = 90, quadsegs = 4)
  cell_counts <- terra::extract(r, bufs)
  
  cell_counts %>% 
    bind_rows() -> cell_counts 
  
  cell_counts %>% 
    group_by(ID, cell_counts[,2]) %>%
    summarise(count = n(), .groups = "drop") -> cell_counts
  
  names(cell_counts)[2] <- "value"
  
    cell_counts %>% 
      left_join(class_df) %>% 
      select(ID, value,description,count) %>% 
      left_join(cell_counts %>% 
              group_by(ID) %>% 
              summarise(total = sum(count), .groups = "drop")) -> cell_counts
    
    cell_counts %>% 
      mutate(per_surface = count/total) %>% 
      select(-value, -count, -total) %>% 
      mutate(description_per = paste0("%_of_",description))%>% 
      select(-description) %>% 
      pivot_wider(names_from = description_per,values_from = per_surface, 
                  values_fill = 0) -> cell_per
    
    cell_counts %>% 
      select(-value, -total) %>% 
      mutate(description_count = paste0("#_of_pix_",description)) %>% 
      select(-description) %>% 
      pivot_wider(names_from = description_count, values_from = count, 
                  values_fill = 0) -> cell_count
    
    left_join(cell_per, cell_count) -> cell_summary
    
  return(cell_summary)
}

```

Calculating Land Cover using land_cover custome function.

```{r, warning=FALSE}

suppressMessages(
  map_dfr(denver_tree_sf$the_geom[1:10], land_cover, .id = "tree_id") %>% 
    mutate(tree_id = as.double(tree_id)))-> lc_data

denver_tree_sf %>% 
  head(10)%>%
  mutate(tree_id = as.double(row_number())) %>% 
  left_join(lc_data, by = "tree_id") 

```

```{r}


rast_search <- function(geom){
  
  ref_DLCD <- read_csv("../data_raw/mis._data_sets/ref_DLCD.csv")

  if (!inherits(geom, "sfc")) {
    geom <- st_sfc(geom, crs = 4326)
  }
  
  rast_id_match <- NA
  coords <- st_coordinates(geom)[1, ]
  x <- coords[1]; y <- coords[2]
  
  for (i in seq_len(nrow(ref_DLCD))) {
    bbox <- ref_DLCD[i, ]
    if (x >= bbox$xmin && x <= bbox$xmax &&
        y >= bbox$ymin && y <= bbox$ymax) {
      rast_id_match <- bbox$rast_id
      break
    }
  }
  
  return(rast(rast_id_match))

}

```

```{r}

#rast_search(denver_tree_sf$the_geom[1])

class(rast_search(denver_tree_sf$the_geom[1]))



```

Mapping Land Cover Raster

```{r}

ggplot() +
  geom_spatraster(data = as.factor(rast_search(denver_tree_sf$the_geom[1])), "EPSG:4326")+
  geom_spatvector(data = buffer(vect(denver_tree_sf$the_geom[1]), width = 90, quadsegs = 4)
                  , fill = "white", color = "white", size = 10) +
  scale_fill_manual(
    name = "Land Cover Type",
    values = class_df$col,
    labels = class_df$description
  )+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) #-> lc_image_1

#ggsave("../images/landcover_map_zoom_out.png", plot = lc_image_1, width = 8, height = 6, dpi = 300)

```

```{r}

lon <- c(-104.893, -104.890)
lat <- c(39.658, 39.660)

# Convert lat/lon to sf polygon
bbox_sf <- st_as_sfc(st_bbox(c(xmin = lon[1], xmax = lon[2], 
                               ymin = lat[1], ymax = lat[2]), crs = 4326))

# Transform to raster CRS (replace with your raster CRS)
bbox_proj <- st_transform(bbox_sf, crs(r))

# Get coordinates in raster CRS
bbox_coords <- st_bbox(bbox_proj)
  
ggplot() +
  geom_spatraster(data = as.factor(rast_search(denver_tree_sf$the_geom[1])), "EPSG:4326")+
  geom_spatvector(data = buffer(vect(denver_tree_sf$the_geom[1]), width = 90, quadsegs = 4)
                  , fill = NA, color = "white", linewidth = 1) +
  geom_sf(data = denver_tree_sf$the_geom[1], color = "pink", size = 3) +
  scale_fill_manual(
    name = "Land Cover Type",
    values = class_df$col,
    labels = class_df$description
  ) +
  coord_sf(
    xlim = c(bbox_coords["xmin"], bbox_coords["xmax"]),
    ylim = c(bbox_coords["ymin"], bbox_coords["ymax"])
  )+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) -> lc_image_2
  

ggsave("../images/landcover_map_zoom_in.png", plot = lc_image_2, width = 8, height = 6, dpi = 300)

```


```{r}

#buffer(vect(denver_tree_sf$the_geom[1]), width = 90, quadsegs = 4))

st_as_sf(buffer(vect(denver_tree_sf$the_geom[1]), width = 90, quadsegs = 4))

```





```{r, warning=FALSE}

denver_tree_sf <- read_rds("../data_raw/denver_tree/denver_tree_clean.rds")

source("../R/land_cover.R")

suppressMessages(
  map_dfr(denver_tree_sf$the_geom[1:10], land_cover, .id = "tree_id") %>% 
    mutate(tree_id = as.double(tree_id)))-> lc_data

denver_tree_sf %>% 
  head(10)%>%
  mutate(tree_id = as.double(row_number())) %>% 
  left_join(lc_data, by = "tree_id") 

```


