---
title: "Exploratory Analysis"
author: "Jared Martin"
format: html
editor: visual
---

```{r}

library(tidyverse)
library(sf)
library(tigris)
library(gridExtra)
library(leaflet)
library(rstac)
library(terra)
library(tidyterra)

```

```{r}

denver_tree <- read_rds("../data_raw/denver_tree/tree_inventory_denver_20250911.rds")

glimpse(denver_tree)

```

```{r}

denver_county <- counties(state = "CO", cb = TRUE) %>%
  filter(NAME == "Denver") %>%
  st_transform(crs = 4326) # adjust to local projection for final sample

```

```{r}

denver_tree %>%
  # Fix formatting of common names: convert "last, first" to "first last"
  mutate(
    species_common = if_else(
      str_detect(species_common, ","),# check if a comma exists
      str_replace(species_common, "^(.*),\\s*(.*)$", "\\2 \\1"), # swap parts around
      species_common  # leave unchanged if no comma
    ),
    # Combine scientific and common names into one column
    botanic_common = paste(species_botanic, "(", species_common, ")"),
    # Standardize disease/pest field: anything containing "N/A" becomes exactly "N/A"
    disease_pest_def = if_else(str_detect(disease_pest_def, "N/A"), 
                               "N/A", disease_pest_def)
    ) %>%
  filter(species_botanic != "Tree requested") %>% # Remove rows with placeholder species
  # Extract the Genus + species (binomial name) from species_botanic
  mutate(
    species_sci = str_extract(species_botanic, "^[A-Za-z]+\\s+x?\\s?[A-Za-z]+")
  ) %>% 
  filter(!is.na(species_sci)) %>% # Keep only rows with a valid species_sci
  st_as_sf(
    wkt = "the_geom", # column with WKT strings
    crs = 4326        # EPSG:4326 (lon/lat in WGS84) adjust to local projection for final sample
    ) %>%
  st_filter(denver_county) %>%  # filtering out trees that are not with Denver County
  filter(x_long < -104.7302) %>% 
  left_join(read_csv2("../data_raw/dc_trees/dc_tree_species.csv"), 
            by = "species_sci") %>% # loading list of dc tree species
  mutate(dc_tree = case_when(
    is.na(dc_tree) ~ FALSE,  # changing na to false
    .default = dc_tree)) %>% 
  left_join(read_csv2("../data_raw/disease_groups/usda_disease_categories"), 
            by = "disease_pest_def") -> denver_tree_sf
 
```

To-do List:

1.  Add filter to exclude the 30 trees near the Denver Airport.
2.  Add in the DC Scientific data using code on 52 to 56 to extract only genus and species from DC.
3.  Calculate the % of surfaces around each tree location.
4.  leaflet_satellite backdrop
5.  shinny app \_ filter tree sci_name

-   filter for cluster or points
-   filter size
-   variables selections (for distributions plots)
-   distribution plot (y %total / x lat or long) \* maybe 3d chart

```{r}

leaflet(denver_tree_sf) %>%
  addTiles()%>%
  addPolygons(
    data = denver_county,
    fillOpacity = 0,        # Transparent fill
    color = "red",          # Boundary color
    weight = 2,             # Line thickness
    opacity = 0.8           # Line opacity
  ) %>% 
  addCircleMarkers(
    radius = 3,
    color = "forestgreen",
    stroke = FALSE,
    fillOpacity = 1,
    clusterOptions = markerClusterOptions()
  )

```

# pulling DLUDS form Microsoft planetrycomputing

```{r}
stac_source <- stac("https://planetarycomputer.microsoft.com/api/stac/v1/")

stac_query <- stac_search(
  q = stac_source,
  collections = "drcog-lulc",
  #bbox = c(-105.12, 39.61, -104.728, 39.7217),
  intersects = denver_county
)

signed_stac_query <- items_sign(
  post_request(stac_query),
  sign_planetary_computer()
)

```

# Maping each landuse

```{r}
urls <- paste0("/vsicurl/", signed_stac_query$features[[51]]$assets$data$href)

r <- rast(urls)

class_df <- map_dfr(signed_stac_query$features[[1]]$assets$data$`classification:classes`, as_tibble)

class_df$col <- paste0("#", class_df$color_hint)

```


```{r}

ggplot() +
  geom_spatraster(data = as.factor(r))+
  scale_fill_manual(
    values = class_df$col,
    labels = class_df$description
  )
  
```
#

```{r}

e <- ext(r)

# Create SpatVector of the four corners
corners <- vect(rbind(
  c(xmin(e), ymin(e)),
  c(xmin(e), ymax(e)),
  c(xmax(e), ymin(e)),
  c(xmax(e), ymax(e))
), crs = crs(r))

corners_ll <- project(corners, "EPSG:4326") # Reproject to WGS84 (lat/lon)

```


```{r}

denver_tree_sf %>%
  filter(
    st_coordinates(the_geom)[,1] >= xmin(corners_ll) &
    st_coordinates(the_geom)[,1] <= xmax(corners_ll) &
    st_coordinates(the_geom)[,2] >= ymin(corners_ll) &
    st_coordinates(the_geom)[,2] <= ymax(corners_ll)) -> denver_tree_sf_filtered

```

```{r}

bufs <- buffer(vect(denver_tree_sf_filtered$the_geom), width = 50, quadsegs = 4) # range 50m  4 = 32 sided octegon  

cell_counts <- extract(r, bufs)

cell_counts %>%
  group_by(ID, cell_counts[,2]) %>%
  summarise(count = n(), .groups = "drop") -> cell_counts

names(cell_counts)[2] <- "value"

cell_counts %>% 
  left_join(class_df) %>% 
  select(ID, value,description,count) %>% 
  left_join(cell_counts %>% 
          group_by(ID) %>% 
          summarise(total = sum(count), .groups = "drop")) %>% 
  mutate(per_surface = count/total) %>% 
  select(-value, -count, -total) %>% 
  mutate(description = paste0("%_of_",description))%>% 
  pivot_wider(names_from = description,values_from = per_surface, values_fill = 0) -> cell_summary

result <- crossing(denver_tree_sf_filtered, cell_summary)

```


# Loop to find the % of land cover

```{r}

results_list <- vector("list", length = 93)

for (i in 1:93) {
  
  cat("Processing tile", i, "of 93...\n")
  
  # Load raster
  r <- rast(paste0("/vsicurl/", signed_stac_query$features[[i]]$assets$data$href))
  
  # Get raster corners and make polygon
  e <- ext(r)
  corners <- vect(rbind(
    c(xmin(e), ymin(e)),
    c(xmin(e), ymax(e)),
    c(xmax(e), ymin(e)),
    c(xmax(e), ymax(e))
  ), crs = crs(r))
  
  corners_ll <- project(corners, "EPSG:4326")
  
  # Filter points inside raster
  denver_tree_sf_filtered <- denver_tree_sf %>%
    filter(
      st_coordinates(the_geom)[,1] >= xmin(corners_ll) &
      st_coordinates(the_geom)[,1] <= xmax(corners_ll) &
      st_coordinates(the_geom)[,2] >= ymin(corners_ll) &
      st_coordinates(the_geom)[,2] <= ymax(corners_ll)
    )
  
  cat("  Points inside tile:", nrow(denver_tree_sf_filtered), "\n")
  
  # Skip if no points in this tile
  if (nrow(denver_tree_sf_filtered) == 0) next
  
  # Create buffers around points
  bufs <- buffer(vect(denver_tree_sf_filtered$the_geom), width = 50, quadsegs = 4)
  
  # Extract raster values
  cell_counts <- terra::extract(r, bufs)
  
  # Summarize counts per class per point
  cell_counts <- cell_counts %>%
    group_by(ID, layer) %>%
    summarise(count = n(), .groups = "drop") 
  
    names(cell_counts)[2] <- "value"
  
  # Join with class info and calculate % coverage
  cell_counts %>% 
    left_join(class_df) %>% 
    select(ID, value,description,count) %>% 
    left_join(cell_counts %>% 
            group_by(ID) %>% 
            summarise(total = sum(count), .groups = "drop")) %>% 
    mutate(per_surface = count/total) %>% 
    select(-value, -count, -total) %>% 
    mutate(description = paste0("%_of_",description))%>% 
    pivot_wider(names_from = description,values_from = per_surface, 
                values_fill = 0) -> cell_summary
  
  # Join back to original points
  results_list[[i]] <-  crossing(denver_tree_sf_filtered, cell_summary)
  
  cat("  Finished tile", i, "\n\n")
}

# Combine all tiles into one data frame
final_results <- bind_rows(results_list)
cat("All tiles processed! Total points:", nrow(final_results), "\n")

```



```{r}

ref_DLCD <- vector("list", length = 93)  # preallocate list

for (i in 1:93) {
  # Load raster
  r <- rast(paste0("/vsicurl/", signed_stac_query$features[[i]]$assets$data$href))
  
  # Get raster corners
  e <- ext(r)
  corners <- vect(rbind(
    c(xmin(e), ymin(e)),
    c(xmin(e), ymax(e)),
    c(xmax(e), ymin(e)),
    c(xmax(e), ymax(e))
  ), crs = crs(r))
  
  corners_ll <- project(corners, "EPSG:4326")
  
  # Store metadata for this raster
  ref_DLCD[[i]] <- data.frame(
    rast_id = paste0("/vsicurl/", signed_stac_query$features[[i]]$assets$data$href),
    xmin = xmin(corners_ll),
    xmax = xmax(corners_ll),
    ymin = ymin(corners_ll),
    ymax = ymax(corners_ll)
  )
  
}

# Bind list into one data frame
ref_DLCD <- dplyr::bind_rows(ref_DLCD)

```

```{r}
land_cover <- function(geom) {
  # wrap raw geometry in sfc with CRS
  if (!inherits(geom, "sfc")) {
    geom <- st_sfc(geom, crs = st_crs(denver_tree_sf))
  }
  
  rast_id_match <- NA
  coords <- st_coordinates(geom)[1, ]
  x <- coords[1]; y <- coords[2]
  
  for (i in seq_len(nrow(ref_DLCD))) {
    bbox <- ref_DLCD[i, ]
    if (x >= bbox$xmin && x <= bbox$xmax &&
        y >= bbox$ymin && y <= bbox$ymax) {
      rast_id_match <- bbox$rast_id
      break
    }
  }
  
  r <- rast(rast_id_match)
  
  bufs <- buffer(vect(geom), width = 50, quadsegs = 4)
  cell_counts <- terra::extract(r, bufs)
  
  cell_counts %>% 
    bind_rows() -> cell_counts 
  
  cell_counts %>% 
    group_by(ID, cell_counts[,2]) %>%
    summarise(count = n(), .groups = "drop") -> cell_counts
  
  names(cell_counts)[2] <- "value"
  
    cell_counts %>% 
      left_join(class_df) %>% 
      select(ID, value,description,count) %>% 
      left_join(cell_counts %>% 
              group_by(ID) %>% 
              summarise(total = sum(count), .groups = "drop")) %>% 
      mutate(per_surface = count/total) %>% 
      select(-value, -count, -total) %>% 
      mutate(description = paste0("%_of_",description))%>% 
      pivot_wider(names_from = description,values_from = per_surface, 
                  values_fill = 0) -> cell_summary
  
  return(cell_summary)
}

```


```{r}

map_dfr(denver_tree_sf$the_geom[1:10], land_cover, .id = "tree_id") %>% 
  mutate(tree_id = as.double(tree_id)) -> lc_data

denver_tree_sf %>% 
  head(10)%>%
  mutate(tree_id = as.double(row_number())) %>% 
  left_join(lc_data, by = "tree_id")

```

